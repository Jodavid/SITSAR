0, Inf )$value
# ------------
},
"Triangular" = {
# ------------
integrate(
function(x)
( dg0i(x,alpha1,gama1,L1) - dg0i(x,alpha2,gama2,L2) )^2/
( dg0i(x,alpha1,gama1,L1) + dg0i(x,alpha2,gama2,L2) ),
0, Inf )$value
# ------------
},
"Harmonic-Mean" = {
# ------------
I <- integrate(
function(x)
( dg0i(x,alpha1,gama1,L1) - dg0i(x,alpha2,gama2,L2) )^2/
( dg0i(x,alpha1,gama1,L1) + dg0i(x,alpha2,gama2,L2) ),
0, Inf )$value
-log(1-I/2)
# ------------
},
)
# --------------------------------------------------------
#-------------------------------------------------------
structure(list(
par_1 = par_1,
par_2 = par_2,
type = type,
distance_value = distance
),
class = "distancesG0I"
)
}
distancesG0I(c(alpha,gama,L),c(alpha,gama,4))
#' @export
print.distancesG0I <- function(x, ...) {
# -----------------
cat("\nDistance Calculation Summary\n\n")
# -----------------
cat("Type:\n")
print(X$type)
cat("Distance:\n")
print(x$distance_value)
# -----------------
}
res <- distancesG0I(c(alpha,gama,L),c(alpha,gama,4))
print(res)
#' @export
print.distancesG0I <- function(x, ...) {
# -----------------
cat("\nDistance Calculation Summary\n\n")
# -----------------
cat("Type:\n")
print(x$type)
cat("Distance:\n")
print(x$distance_value)
# -----------------
}
print(res)
Densities <- data.frame(
z <- seq(-1, 1, length.out=500),
s1 = d1(z),
s2 = d2(z),
s3 = d3(z),
s4 = d4(z),
s5 = d5(z),
s6 = d6(z),
s7 = d7(z)
)
Densities
Densities <- data.frame(
z <- seq(-1, 1, length.out=500),
s1 = d1(z),
s2 = d2(z),
s3 = d3(z),
s4 = d4(z),
s5 = d5(z),
s6 = d6(z),
s7 = d7(z)
)
require(reshape2)
require(ggplot2)
require(extrafont)
require(ggthemes)
theme_set(theme_pander(base_size = 20, base_family = 'serif' ))
my.colors <- c("#000000", #black
"#4daf4a", # green
"#377eb8", # blue
"#e41a1c", # red
"#984ea3",  # purple
"#69b3a2",
"#D55E00"
)
Densities.melt <- melt(Densities, measure.vars = 2:8, variable.name = "Parameter")
res$distance_value
Densities <- data.frame(
z <- seq(-1, 1, length.out=500),
s1 = distancesG0I(z)$distance_value,
s2 = d2(z),
s3 = d3(z),
s4 = d4(z),
s5 = d5(z),
s6 = d6(z),
s7 = d7(z)
)
devtools::check()
distancesG0I
devtools::check()
devtools::check()
par_1
par_1 <- c(alpha,gama,L)
par_2 <- c(alpha,gama,4)
length(vec)
#--------------
vec <- c("KL", "Renyi", "Bhattacharyya", "Hellinger",
"Arithmetic-Geometric", "Triangular", "Harmonic-Mean")
length(vec)
sapply(1:length(vec), function(i) distancesG0I.default(par_1,par_2,type = vec[i]))
sapply(1:length(vec), function(i) distancesG0I.default(par_1,par_2,type = vec[i])$distance_value)
data("SanFrancisco150")
image <- SanFrancisco150
image
# left,right, up,down)
marks1 <- c(10,30,50,100)
marks2 <- c(20,50,80,130)
data("SanFrancisco150")
dim(image)
sample1 <- sapply(1:3, function(i) image[marks1[3]:marks1[4], marks1[1]:marks1[2],i])
sample1
20*50
21*51
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
# left,right, up,down)
marks1 <- c(10,10,50,100)
marks2 <- c(20,20,80,130)
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
sample1
sample2
# left,right, up,down)
marks1 <- c(10,30,50,100)
marks2 <- c(20,50,80,130)
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
marks1
any(marks1)
?any
any(marks1 == 0 )
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
sample1
sample2
#' alpha <- -1.5
#' gama <- 2
#' L <- 8
#' Xobs2<- rg0i(100,alpha,gama,L)
#' estimatorg0I(c(alpha,gama,L), Xobs2)
#' estimatorg0I(c(-1.1,1,1),Xobs2)
#'
#' @importFrom maxLik maxLik
#'
#' @export
estimatorg0I = function(initial, Xobs, method ="NM"){
A <- rbind(
c(-1, 0, 0),
c(0, 1, 0),
c(0, 0, 1))
B <- c(0, 0, 0)
rr = maxLik::maxLik(loglikeg0i,
start=initial,
Xobs = Xobs,
constraints=list(ineqA=A, ineqB=B),
method = method);
estimate <- stats::coef(rr)
return(estimate)
}
loglikeg0i = function(theta, Xobs){
# ..> GI0 log-likelihood
res <- mean(log(dg0i(Xobs,theta[1],theta[2],theta[3])),na.rm=T)
return(res)
}
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample1[,i]))
estimatingsample1
estimatingsample2 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample2[,i]))
estimatingsample2
j=1
estimatingsample1[[j]]
sapply(1:3,function(j){
sapply(1:length(vec), function(i){
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
})
t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
res <- t(sapply1:3,function(j){
sapply(1:length(vec), function(i){
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
res <- t(sapply1:3,function(j){
sapply(1:length(vec), function(i){
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
t(sapply1:3,function(j){
sapply(1:length(vec), function(i){
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
t(sapply1:3,function(j){
sapply(1:length(vec), function(i){
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
})
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
res
#--------------
colnames(res) <- vec
res
rownames(res) <- c("HH", "HV", "VV")
#' @export
distancesG0Itable.default = function(image,marks1, marks2, p = 1/2){
# --------------------------------------------------------
if(length(marks1) != 4 | length(marks2) != 4 | any(marks1 == 0 ) | any(marks2 == 0 ) ){
stop("Your need to redefine the marks1 and/or marks2")
}
# --------------------------------------------------------
# Selecting the samples
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample1[,i]))
estimatingsample2 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample2[,i]))
#--------------
# Calculating the distances
vec <- c("KL", "Renyi", "Bhattacharyya", "Hellinger",
"Arithmetic-Geometric", "Triangular", "Harmonic-Mean")
#--------------
cat("Calculating the distances")
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
# --
cat(".")
# --
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
#--------------
colnames(res) <- vec
rownames(res) <- c("HH", "HV", "VV")
}
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
distancesG0Itable = function(par_1, par_2, p = 1/2){
UseMethod("distancesG0Itable")
}
#' @export
distancesG0Itable.default = function(image,marks1, marks2, p = 1/2){
# --------------------------------------------------------
if(length(marks1) != 4 | length(marks2) != 4 | any(marks1 == 0 ) | any(marks2 == 0 ) ){
stop("Your need to redefine the marks1 and/or marks2")
}
# --------------------------------------------------------
# Selecting the samples
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample1[,i]))
estimatingsample2 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample2[,i]))
#--------------
# Calculating the distances
vec <- c("KL", "Renyi", "Bhattacharyya", "Hellinger",
"Arithmetic-Geometric", "Triangular", "Harmonic-Mean")
#--------------
cat("Calculating the distances")
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
# --
cat(".")
# --
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
#--------------
colnames(res) <- vec
rownames(res) <- c("HH", "HV", "VV")
}
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
#' @export
distancesG0Itable.default = function(image, marks1, marks2, p = 1/2){
# --------------------------------------------------------
if(length(marks1) != 4 | length(marks2) != 4 | any(marks1 == 0 ) | any(marks2 == 0 ) ){
stop("Your need to redefine the marks1 and/or marks2")
}
# --------------------------------------------------------
# Selecting the samples
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample1[,i]))
estimatingsample2 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample2[,i]))
#--------------
# Calculating the distances
vec <- c("KL", "Renyi", "Bhattacharyya", "Hellinger",
"Arithmetic-Geometric", "Triangular", "Harmonic-Mean")
#--------------
cat("Calculating the distances")
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
# --
cat(".")
# --
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
#--------------
colnames(res) <- vec
rownames(res) <- c("HH", "HV", "VV")
}
#' L <- 8
#'
#' distancesG0I(c(alpha,gama,L),c(alpha,gama,L))
#' res <- distancesG0I(c(alpha,gama,L),c(alpha,gama,4))
#' print(res)
#'
#'
#' @importFrom stats integrate
#'
#' @export
distancesG0I = function(par_1, par_2, p = 1/2, type = "KL"){
UseMethod("distancesG0I")
}
distancesG0Itable = function(image, marks1, marks2, p = 1/2){
UseMethod("distancesG0Itable")
}
#' @export
distancesG0Itable.default = function(image, marks1, marks2, p = 1/2){
# --------------------------------------------------------
if(length(marks1) != 4 | length(marks2) != 4 | any(marks1 == 0 ) | any(marks2 == 0 ) ){
stop("Your need to redefine the marks1 and/or marks2")
}
# --------------------------------------------------------
# Selecting the samples
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample1[,i]))
estimatingsample2 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample2[,i]))
#--------------
# Calculating the distances
vec <- c("KL", "Renyi", "Bhattacharyya", "Hellinger",
"Arithmetic-Geometric", "Triangular", "Harmonic-Mean")
#--------------
cat("Calculating the distances")
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
# --
cat(".")
# --
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
#--------------
colnames(res) <- vec
rownames(res) <- c("HH", "HV", "VV")
}
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
teste
#' @export
print.distancesG0I <- function(x, ...) {
# -----------------
cat("\nDistances Table\n\n")
# -----------------
print(x$distancestable)
# -----------------
}
#' @export
print.distancesG0Itable <- function(x, ...) {
# -----------------
cat("\nDistances Table\n\n")
# -----------------
print(x$distancestable)
# -----------------
}
#' @export
distancesG0Itable.default = function(image, marks1, marks2, p = 1/2){
# --------------------------------------------------------
if(length(marks1) != 4 | length(marks2) != 4 | any(marks1 == 0 ) | any(marks2 == 0 ) ){
stop("Your need to redefine the marks1 and/or marks2")
}
# --------------------------------------------------------
# Selecting the samples
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample1[,i]))
estimatingsample2 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample2[,i]))
#--------------
# Calculating the distances
vec <- c("KL", "Renyi", "Bhattacharyya", "Hellinger",
"Arithmetic-Geometric", "Triangular", "Harmonic-Mean")
#--------------
cat("Calculating the distances")
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
# --
cat(".")
# --
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
#--------------
colnames(res) <- vec
rownames(res) <- c("HH", "HV", "VV")
#-------------------------------------------------------
structure(list(
marks1 = marks1,
marks2 = marks2,
distancestable = res
),
class = "distancesG0Itable"
)
}
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
teste
print(distancesG0Itable)
teste
# left,right, up,down)
marks1 <- c(10,10,50,100)
marks2 <- c(20,50,80,130)
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
teste
# left,right, up,down)
marks1 <- c(10,0,50,100)
marks2 <- c(20,50,80,130)
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
# left,right, up,down)
marks1 <- c(10,1,50,100)
marks2 <- c(20,50,80,130)
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
teste
image
class(image)
dm(image)
dim(image)
devtools::check()
devtools::check()
# Construir pacote
devtools::build()
# instalando pacote - localmente
install.packages("../SITSAR_0.0.0.9000.tar.gz", repos = NULL, type = "source")
# Construir manual
devtools::build_manual()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
# Construir pacote
devtools::build()
# instalando pacote - localmente
install.packages("../SITSAR_0.0.0.9000.tar.gz", repos = NULL, type = "source")
# Construir manual
devtools::build_manual()
library(SITSAR)
set.seed(1) # determining a seed
alpha <- -1.5
gama <- 2
L <- 8
Xobs<- rg0i(100,alpha, gama, L)
dg0i(Xobs,alpha, gama, L)
library(SITSAR)
set.seed(1) # determining a seed
alpha <- -1.5
gama <- 2
L <- 8
distancesg0i(c(alpha,gama,L),c(alpha,gama,L))
res <- distancesg0i(c(alpha,gama,L),c(alpha,gama,4))
print(res)
library(SITSAR)
set.seed(1) # determining a seed
data("SanFrancisco150")
image <- SanFrancisco150
# left,right, up,down)
marks1 <- c(10,30,50,100)
marks2 <- c(20,50,80,130)
teste <- distancesg0itable(image,marks1, marks2, p = 1/2)
teste
library(SITSAR)
set.seed(1) # determining a seed
alpha <- -1.5
gama <- 2
L <- 8
Xobs2<- rg0i(100,alpha,gama,L)
estimatorg0i(c(alpha,gama,L), Xobs2)
estimatorg0i(c(-1.1,1,1),Xobs2)
