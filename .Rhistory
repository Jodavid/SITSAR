#--------------
# Calculating the distances
vec <- c("KL", "Renyi", "Bhattacharyya", "Hellinger",
"Arithmetic-Geometric", "Triangular", "Harmonic-Mean")
#--------------
cat("Calculating the distances")
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
# --
cat(".")
# --
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
#--------------
colnames(res) <- vec
rownames(res) <- c("HH", "HV", "VV")
}
#' L <- 8
#'
#' distancesG0I(c(alpha,gama,L),c(alpha,gama,L))
#' res <- distancesG0I(c(alpha,gama,L),c(alpha,gama,4))
#' print(res)
#'
#'
#' @importFrom stats integrate
#'
#' @export
distancesG0I = function(par_1, par_2, p = 1/2, type = "KL"){
UseMethod("distancesG0I")
}
distancesG0Itable = function(image, marks1, marks2, p = 1/2){
UseMethod("distancesG0Itable")
}
#' @export
distancesG0Itable.default = function(image, marks1, marks2, p = 1/2){
# --------------------------------------------------------
if(length(marks1) != 4 | length(marks2) != 4 | any(marks1 == 0 ) | any(marks2 == 0 ) ){
stop("Your need to redefine the marks1 and/or marks2")
}
# --------------------------------------------------------
# Selecting the samples
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample1[,i]))
estimatingsample2 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample2[,i]))
#--------------
# Calculating the distances
vec <- c("KL", "Renyi", "Bhattacharyya", "Hellinger",
"Arithmetic-Geometric", "Triangular", "Harmonic-Mean")
#--------------
cat("Calculating the distances")
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
# --
cat(".")
# --
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
#--------------
colnames(res) <- vec
rownames(res) <- c("HH", "HV", "VV")
}
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
teste
#' @export
print.distancesG0I <- function(x, ...) {
# -----------------
cat("\nDistances Table\n\n")
# -----------------
print(x$distancestable)
# -----------------
}
#' @export
print.distancesG0Itable <- function(x, ...) {
# -----------------
cat("\nDistances Table\n\n")
# -----------------
print(x$distancestable)
# -----------------
}
#' @export
distancesG0Itable.default = function(image, marks1, marks2, p = 1/2){
# --------------------------------------------------------
if(length(marks1) != 4 | length(marks2) != 4 | any(marks1 == 0 ) | any(marks2 == 0 ) ){
stop("Your need to redefine the marks1 and/or marks2")
}
# --------------------------------------------------------
# Selecting the samples
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample1[,i]))
estimatingsample2 <- lapply(1:3, function(i) estimatorg0I(c(-1.1,1,1), sample2[,i]))
#--------------
# Calculating the distances
vec <- c("KL", "Renyi", "Bhattacharyya", "Hellinger",
"Arithmetic-Geometric", "Triangular", "Harmonic-Mean")
#--------------
cat("Calculating the distances")
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
# --
cat(".")
# --
distancesG0I.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
#--------------
colnames(res) <- vec
rownames(res) <- c("HH", "HV", "VV")
#-------------------------------------------------------
structure(list(
marks1 = marks1,
marks2 = marks2,
distancestable = res
),
class = "distancesG0Itable"
)
}
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
teste
print(distancesG0Itable)
teste
# left,right, up,down)
marks1 <- c(10,10,50,100)
marks2 <- c(20,50,80,130)
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
teste
# left,right, up,down)
marks1 <- c(10,0,50,100)
marks2 <- c(20,50,80,130)
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
# left,right, up,down)
marks1 <- c(10,1,50,100)
marks2 <- c(20,50,80,130)
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
teste <- distancesG0Itable(image,marks1, marks2, p = 1/2)
teste
image
class(image)
dm(image)
dim(image)
devtools::check()
devtools::check()
# Construir pacote
devtools::build()
# instalando pacote - localmente
install.packages("../SITSAR_0.0.0.9000.tar.gz", repos = NULL, type = "source")
# Construir manual
devtools::build_manual()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
# Construir pacote
devtools::build()
# instalando pacote - localmente
install.packages("../SITSAR_0.0.0.9000.tar.gz", repos = NULL, type = "source")
# Construir manual
devtools::build_manual()
library(SITSAR)
set.seed(1) # determining a seed
alpha <- -1.5
gama <- 2
L <- 8
Xobs<- rg0i(100,alpha, gama, L)
dg0i(Xobs,alpha, gama, L)
library(SITSAR)
set.seed(1) # determining a seed
alpha <- -1.5
gama <- 2
L <- 8
distancesg0i(c(alpha,gama,L),c(alpha,gama,L))
res <- distancesg0i(c(alpha,gama,L),c(alpha,gama,4))
print(res)
library(SITSAR)
set.seed(1) # determining a seed
data("SanFrancisco150")
image <- SanFrancisco150
# left,right, up,down)
marks1 <- c(10,30,50,100)
marks2 <- c(20,50,80,130)
teste <- distancesg0itable(image,marks1, marks2, p = 1/2)
teste
library(SITSAR)
set.seed(1) # determining a seed
alpha <- -1.5
gama <- 2
L <- 8
Xobs2<- rg0i(100,alpha,gama,L)
estimatorg0i(c(alpha,gama,L), Xobs2)
estimatorg0i(c(-1.1,1,1),Xobs2)
?devtools::build()
devtools::build(binary = T)
# Construir pacote
devtools::build(manual = T)
#devtools::check_win_devel()
rhub::check_for_cran()
devtools::install_github("jodavid/SITSAR")
devtools::check()
# Construir pacote
devtools::build(manual = T)
# instalando pacote - localmente
install.packages("../SITSAR_0.0.0.9000.tar.gz", repos = NULL, type = "source")
# Construir manual
devtools::build_manual()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
?qnorm
pnorm(1:10)
qnorm(1:10)
qnorm(runif(10))
?dg0i
devtools::check()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
pkgload::dev_help('g0i')
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
pkgload::dev_help('g0i')
devtools::document()
devtools::check()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
data("SanFrancisco150")
image <- SanFrancisco150
# left,right, up,down)
marks1 <- c(10,30,50,100)
marks2 <- c(20,50,80,130)
teste <- distancesg0itable(image,marks1, marks2, p = 1/2)
p = 1/2
marks2
marks1
image
# Selecting the samples
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
sample1
sample2
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) g0iestimation(c(-1.1,1,1), sample1[,i]))
estimatingsample2 <- lapply(1:3, function(i) g0iestimation(c(-1.1,1,1), sample2[,i]))
estimatingsample1
estimatingsample2
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
# --
cat(".")
# --
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
#--------------
# Calculating the distances
vec <- c("KL", "Renyi", "Bhattacharyya", "Hellinger",
"Arithmetic-Geometric", "Triangular", "Harmonic-Mean")
#--------------
cat("Calculating the distances")
res <- t(sapply(1:3,function(j){
sapply(1:length(vec), function(i){
# --
cat(".")
# --
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
}))
#--------------
colnames(res) <- vec
rownames(res) <- c("HH", "HV", "VV")
j=1
estimatingsample1[[j]]
estimatingsample2[[j]]
par1 = estimatingsample1[[j]]
par2 = estimatingsample2[[j]]
# --------------------------------------------------------
alpha1 <- par_1[1]
gama1 <- par_1[2]
L1 <- par_1[3]
par_1 = estimatingsample1[[j]]
par_2 = estimatingsample2[[j]]
# --------------------------------------------------------
alpha1 <- par_1[1]
gama1 <- par_1[2]
L1 <- par_1[3]
alpha2 <- par_2[1]
gama2 <- par_2[2]
L2 <- par_2[3]
alpha1
gama1
L1
alpha2
gama2
L2
x
dg0i
x
dg0i(1,alpha1,gama1,L1)
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])
i=1
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value
devtools::document()
devtools::check()
distancesg0itable(image,marks1, marks2, p = 1/2)
devtools::document()
devtools::check()
devtools::document()
devtools::check()
dim(image)
image
marks1
marks2
p = 1/2
# Selecting the samples
sample1 <- sapply(1:3, function(i) Re(image[marks1[3]:marks1[4], marks1[1]:marks1[2],i]))
sample1
sample2 <- sapply(1:3, function(i) Re(image[marks2[3]:marks2[4], marks2[1]:marks2[2],i]))
sample2
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) g0iestimation(c(-1.1,1,1), sample1[,i]))
estimatingsample2 <- lapply(1:3, function(i) g0iestimation(c(-1.1,1,1), sample2[,i]))
estimatingsample1
estimatingsample2
j=2
sapply(1:length(vec), function(i){
# --
#cat(".")
cat(paste(j,"-", i,vec[i],"|"))
# --
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
i=1
estimatingsample1[[j]]
estimatingsample2[[j]]
type = vec[i]
par_1
par_2
par_1 = estimatingsample1[[j]]
par_2 = estimatingsample2[[j]]
par_1
par_2
# --------------------------------------------------------
alpha1 <- par_1[1]
gama1 <- par_1[2]
L1 <- par_1[3]
alpha2 <- par_2[1]
gama2 <- par_2[2]
L2 <- par_2[3]
dg0i(x,alpha1,gama1,L1)
x = .1
dg0i(x,alpha1,gama1,L1)
dg0i(x,alpha2,gama2,L2)
dg0i(x,alpha1,gama1,L1)/dg0i(x,alpha2,gama2,L2)
( dg0i(x,alpha1,gama1,L1)-dg0i(x,alpha2,gama2,L2) ) *
log( dg0i(x,alpha1,gama1,L1)/dg0i(x,alpha2,gama2,L2) )
estimatingsample1
estimatingsample2
estimatingsample2[[2]][3] <- 3
estimatingsample2
j
i
sapply(1:length(vec), function(i){
# --
#cat(".")
cat(paste(j,"-", i,vec[i],"|"))
# --
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
# Estimating Parameters
estimatingsample1 <- lapply(1:3, function(i) g0iestimation(c(-1.1,1,1), sample1[,i]))
estimatingsample2 <- lapply(1:3, function(i) g0iestimation(c(-1.1,1,1), sample2[,i]))
estimatingsample1
estimatingsample2
#estimatingsample2[[2]][3] <- 3
estimatingsample1[[2]][3] <- 3
sapply(1:length(vec), function(i){
# --
#cat(".")
cat(paste(j,"-", i,vec[i],"|"))
# --
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
#estimatingsample2[[2]][3] <- 3
estimatingsample1[[2]][3] <- 50
sapply(1:length(vec), function(i){
# --
#cat(".")
cat(paste(j,"-", i,vec[i],"|"))
# --
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
#estimatingsample2[[2]][3] <- 3
estimatingsample1[[2]][3] <- 30
sapply(1:length(vec), function(i){
# --
#cat(".")
cat(paste(j,"-", i,vec[i],"|"))
# --
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
#estimatingsample2[[2]][3] <- 3
estimatingsample1[[2]][3] <- 40
sapply(1:length(vec), function(i){
# --
#cat(".")
cat(paste(j,"-", i,vec[i],"|"))
# --
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
#estimatingsample2[[2]][3] <- 3
estimatingsample1[[2]][3] <- 35
sapply(1:length(vec), function(i){
# --
#cat(".")
cat(paste(j,"-", i,vec[i],"|"))
# --
distancesg0i.default(estimatingsample1[[j]],estimatingsample2[[j]],
type = vec[i])$distance_value})
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::install_github("jodavid/SITSAR")
# import package
library(SITSAR)
# import package
library(SITSAR)
set.seed(1) # determining a seed
alpha <- -1.5
gama <- 2
L <- 8
Xobs<- rg0i(100,alpha, gama, L)
Xobs
dg0i(Xobs,alpha, gama, L)
# The parameter L is estimated.
g0iestimation(c(alpha,gama,L), Xobs2)
# The parameter L is estimated.
g0iestimation(c(alpha,gama,L), Xobs)
# The parameter L is fixed.
g0iestimation(c(-1.1,1,8),Xobs, L_fixed = TRUE)
Xobs2<- rg0i(100,alpha,gama,L)
# The parameter L is estimated.
g0iestimation(c(alpha,gama,L), Xobs)
# The parameter L is fixed.
g0iestimation(c(-1.1,1,8),Xobs, L_fixed = TRUE)
distancesg0i(c(alpha,gama,L),c(alpha,gama,L))
res <- distancesg0i(c(alpha,gama,L),c(alpha,gama,4))
print(res)
set.seed(1) # determining a seed
data("SanFrancisco150")
image <- SanFrancisco150
# left,right, up,down)
marks1 <- c(10,30,50,100)
marks2 <- c(20,50,80,130)
teste <- distancesg0itable(image,marks1, marks2, p = 1/2)
teste
set.seed(1) # determining a seed
alpha <- -1.5
gama <- 2
L <- 4
Xobs<- rg0i(100,alpha, gama, L)
dg0i(Xobs,alpha, gama, L)
Xobs<- rg0i(100,alpha,gama,L)
# The parameter L is estimated.
g0iestimation(c(alpha,gama,L), Xobs)
L <- 5
Xobs<- rg0i(100,alpha, gama, L)
dg0i(Xobs,alpha, gama, L)
Xobs<- rg0i(100,alpha,gama,L)
# The parameter L is estimated.
g0iestimation(c(alpha,gama,L), Xobs)
set.seed(1) # determining a seed
alpha <- -1.5
gama <- 2
L <- 6
Xobs<- rg0i(100,alpha,gama,L)
# The parameter L is estimated.
g0iestimation(c(alpha,gama,L), Xobs)
L <- 1
Xobs<- rg0i(100,alpha,gama,L)
# The parameter L is estimated.
g0iestimation(c(alpha,gama,L), Xobs)
